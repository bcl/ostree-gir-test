// This file was generated by gir (???) from gir-files (???)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals)]

extern crate libc;
#[macro_use] extern crate bitflags;
extern crate glib_sys as glib;
extern crate gio_sys as gio;
extern crate gobject_sys as gobject;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType, Volatile};

// Enums
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum OstreeDeploymentUnlockedState {
    None = 0,
    Development = 1,
    Hotfix = 2,
}
pub const OSTREE_DEPLOYMENT_UNLOCKED_NONE: OstreeDeploymentUnlockedState = OstreeDeploymentUnlockedState::None;
pub const OSTREE_DEPLOYMENT_UNLOCKED_DEVELOPMENT: OstreeDeploymentUnlockedState = OstreeDeploymentUnlockedState::Development;
pub const OSTREE_DEPLOYMENT_UNLOCKED_HOTFIX: OstreeDeploymentUnlockedState = OstreeDeploymentUnlockedState::Hotfix;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum OstreeGpgSignatureAttr {
    Valid = 0,
    SigExpired = 1,
    KeyExpired = 2,
    KeyRevoked = 3,
    KeyMissing = 4,
    Fingerprint = 5,
    Timestamp = 6,
    ExpTimestamp = 7,
    PubkeyAlgoName = 8,
    HashAlgoName = 9,
    UserName = 10,
    UserEmail = 11,
}
pub const OSTREE_GPG_SIGNATURE_ATTR_VALID: OstreeGpgSignatureAttr = OstreeGpgSignatureAttr::Valid;
pub const OSTREE_GPG_SIGNATURE_ATTR_SIG_EXPIRED: OstreeGpgSignatureAttr = OstreeGpgSignatureAttr::SigExpired;
pub const OSTREE_GPG_SIGNATURE_ATTR_KEY_EXPIRED: OstreeGpgSignatureAttr = OstreeGpgSignatureAttr::KeyExpired;
pub const OSTREE_GPG_SIGNATURE_ATTR_KEY_REVOKED: OstreeGpgSignatureAttr = OstreeGpgSignatureAttr::KeyRevoked;
pub const OSTREE_GPG_SIGNATURE_ATTR_KEY_MISSING: OstreeGpgSignatureAttr = OstreeGpgSignatureAttr::KeyMissing;
pub const OSTREE_GPG_SIGNATURE_ATTR_FINGERPRINT: OstreeGpgSignatureAttr = OstreeGpgSignatureAttr::Fingerprint;
pub const OSTREE_GPG_SIGNATURE_ATTR_TIMESTAMP: OstreeGpgSignatureAttr = OstreeGpgSignatureAttr::Timestamp;
pub const OSTREE_GPG_SIGNATURE_ATTR_EXP_TIMESTAMP: OstreeGpgSignatureAttr = OstreeGpgSignatureAttr::ExpTimestamp;
pub const OSTREE_GPG_SIGNATURE_ATTR_PUBKEY_ALGO_NAME: OstreeGpgSignatureAttr = OstreeGpgSignatureAttr::PubkeyAlgoName;
pub const OSTREE_GPG_SIGNATURE_ATTR_HASH_ALGO_NAME: OstreeGpgSignatureAttr = OstreeGpgSignatureAttr::HashAlgoName;
pub const OSTREE_GPG_SIGNATURE_ATTR_USER_NAME: OstreeGpgSignatureAttr = OstreeGpgSignatureAttr::UserName;
pub const OSTREE_GPG_SIGNATURE_ATTR_USER_EMAIL: OstreeGpgSignatureAttr = OstreeGpgSignatureAttr::UserEmail;

pub type GpgSignatureFormatFlags = c_int;
pub const OSTREE_GPG_SIGNATURE_FORMAT_DEFAULT: GpgSignatureFormatFlags = 0;
pub type OstreeGpgSignatureFormatFlags = GpgSignatureFormatFlags;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum OstreeObjectType {
    File = 1,
    DirTree = 2,
    DirMeta = 3,
    Commit = 4,
    TombstoneCommit = 5,
    CommitMeta = 6,
}
pub const OSTREE_OBJECT_TYPE_FILE: OstreeObjectType = OstreeObjectType::File;
pub const OSTREE_OBJECT_TYPE_DIR_TREE: OstreeObjectType = OstreeObjectType::DirTree;
pub const OSTREE_OBJECT_TYPE_DIR_META: OstreeObjectType = OstreeObjectType::DirMeta;
pub const OSTREE_OBJECT_TYPE_COMMIT: OstreeObjectType = OstreeObjectType::Commit;
pub const OSTREE_OBJECT_TYPE_TOMBSTONE_COMMIT: OstreeObjectType = OstreeObjectType::TombstoneCommit;
pub const OSTREE_OBJECT_TYPE_COMMIT_META: OstreeObjectType = OstreeObjectType::CommitMeta;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum OstreeRepoCheckoutMode {
    None = 0,
    User = 1,
}
pub const OSTREE_REPO_CHECKOUT_MODE_NONE: OstreeRepoCheckoutMode = OstreeRepoCheckoutMode::None;
pub const OSTREE_REPO_CHECKOUT_MODE_USER: OstreeRepoCheckoutMode = OstreeRepoCheckoutMode::User;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum OstreeRepoCheckoutOverwriteMode {
    None = 0,
    UnionFiles = 1,
    AddFiles = 2,
}
pub const OSTREE_REPO_CHECKOUT_OVERWRITE_NONE: OstreeRepoCheckoutOverwriteMode = OstreeRepoCheckoutOverwriteMode::None;
pub const OSTREE_REPO_CHECKOUT_OVERWRITE_UNION_FILES: OstreeRepoCheckoutOverwriteMode = OstreeRepoCheckoutOverwriteMode::UnionFiles;
pub const OSTREE_REPO_CHECKOUT_OVERWRITE_ADD_FILES: OstreeRepoCheckoutOverwriteMode = OstreeRepoCheckoutOverwriteMode::AddFiles;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum OstreeRepoCommitFilterResult {
    Allow = 0,
    Skip = 1,
}
pub const OSTREE_REPO_COMMIT_FILTER_ALLOW: OstreeRepoCommitFilterResult = OstreeRepoCommitFilterResult::Allow;
pub const OSTREE_REPO_COMMIT_FILTER_SKIP: OstreeRepoCommitFilterResult = OstreeRepoCommitFilterResult::Skip;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum OstreeRepoCommitIterResult {
    Error = 0,
    End = 1,
    File = 2,
    Dir = 3,
}
pub const OSTREE_REPO_COMMIT_ITER_RESULT_ERROR: OstreeRepoCommitIterResult = OstreeRepoCommitIterResult::Error;
pub const OSTREE_REPO_COMMIT_ITER_RESULT_END: OstreeRepoCommitIterResult = OstreeRepoCommitIterResult::End;
pub const OSTREE_REPO_COMMIT_ITER_RESULT_FILE: OstreeRepoCommitIterResult = OstreeRepoCommitIterResult::File;
pub const OSTREE_REPO_COMMIT_ITER_RESULT_DIR: OstreeRepoCommitIterResult = OstreeRepoCommitIterResult::Dir;

pub type RepoListRefsExtFlags = c_int;
pub const OSTREE_REPO_LIST_REFS_EXT_NONE: RepoListRefsExtFlags = 0;
pub type OstreeRepoListRefsExtFlags = RepoListRefsExtFlags;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum OstreeRepoMode {
    Bare = 0,
    ArchiveZ2 = 1,
    BareUser = 2,
}
pub const OSTREE_REPO_MODE_BARE: OstreeRepoMode = OstreeRepoMode::Bare;
pub const OSTREE_REPO_MODE_ARCHIVE_Z2: OstreeRepoMode = OstreeRepoMode::ArchiveZ2;
pub const OSTREE_REPO_MODE_BARE_USER: OstreeRepoMode = OstreeRepoMode::BareUser;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum OstreeRepoPruneFlags {
    None = 0,
    NoPrune = 1,
    RefsOnly = 2,
}
pub const OSTREE_REPO_PRUNE_FLAGS_NONE: OstreeRepoPruneFlags = OstreeRepoPruneFlags::None;
pub const OSTREE_REPO_PRUNE_FLAGS_NO_PRUNE: OstreeRepoPruneFlags = OstreeRepoPruneFlags::NoPrune;
pub const OSTREE_REPO_PRUNE_FLAGS_REFS_ONLY: OstreeRepoPruneFlags = OstreeRepoPruneFlags::RefsOnly;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum OstreeRepoRemoteChange {
    Add = 0,
    AddIfNotExists = 1,
    Delete = 2,
    DeleteIfExists = 3,
}
pub const OSTREE_REPO_REMOTE_CHANGE_ADD: OstreeRepoRemoteChange = OstreeRepoRemoteChange::Add;
pub const OSTREE_REPO_REMOTE_CHANGE_ADD_IF_NOT_EXISTS: OstreeRepoRemoteChange = OstreeRepoRemoteChange::AddIfNotExists;
pub const OSTREE_REPO_REMOTE_CHANGE_DELETE: OstreeRepoRemoteChange = OstreeRepoRemoteChange::Delete;
pub const OSTREE_REPO_REMOTE_CHANGE_DELETE_IF_EXISTS: OstreeRepoRemoteChange = OstreeRepoRemoteChange::DeleteIfExists;

pub type RepoResolveRevExtFlags = c_int;
pub const OSTREE_REPO_RESOLVE_REV_EXT_NONE: RepoResolveRevExtFlags = 0;
pub type OstreeRepoResolveRevExtFlags = RepoResolveRevExtFlags;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum OstreeStaticDeltaGenerateOpt {
    Lowlatency = 0,
    Major = 1,
}
pub const OSTREE_STATIC_DELTA_GENERATE_OPT_LOWLATENCY: OstreeStaticDeltaGenerateOpt = OstreeStaticDeltaGenerateOpt::Lowlatency;
pub const OSTREE_STATIC_DELTA_GENERATE_OPT_MAJOR: OstreeStaticDeltaGenerateOpt = OstreeStaticDeltaGenerateOpt::Major;

// Constants
pub const OSTREE_COMMIT_GVARIANT_STRING: &'static str = r##"(a{sv}aya(say)sstayay)"##;
pub const OSTREE_DIRMETA_GVARIANT_STRING: &'static str = r##"(uuua(ayay))"##;
pub const OSTREE_FILEMETA_GVARIANT_STRING: &'static str = r##"(uuua(ayay))"##;
pub const OSTREE_MAX_METADATA_SIZE: i32 = 10485760;
pub const OSTREE_MAX_METADATA_WARN_SIZE: i32 = 7340032;
pub const OSTREE_MAX_RECURSION: i32 = 256;
pub const OSTREE_SHA256_DIGEST_LEN: i32 = 32;
pub const OSTREE_SHA256_STRING_LEN: i32 = 64;
pub const OSTREE_SUMMARY_GVARIANT_STRING: &'static str = r##"(a(s(taya{sv}))a{sv})"##;
pub const OSTREE_SUMMARY_SIG_GVARIANT_STRING: &'static str = r##"a{sv}"##;
pub const OSTREE_TIMESTAMP: i32 = 0;
pub const OSTREE_TREE_GVARIANT_STRING: &'static str = r##"(a(say)a(sayay))"##;
pub const OSTREE_WITH_AUTOCLEANUPS: i32 = 0;

// Flags
bitflags! {
    #[repr(C)]
    flags OstreeDiffFlags: c_uint {
        const OSTREE_DIFF_FLAGS_NONE = 0,
        const OSTREE_DIFF_FLAGS_IGNORE_XATTRS = 1,
    }
}

bitflags! {
    #[repr(C)]
    flags OstreeRepoCommitModifierFlags: c_uint {
        const OSTREE_REPO_COMMIT_MODIFIER_FLAGS_NONE = 0,
        const OSTREE_REPO_COMMIT_MODIFIER_FLAGS_SKIP_XATTRS = 1,
        const OSTREE_REPO_COMMIT_MODIFIER_FLAGS_GENERATE_SIZES = 2,
    }
}

bitflags! {
    #[repr(C)]
    flags OstreeRepoCommitState: c_uint {
        const OSTREE_REPO_COMMIT_STATE_PARTIAL = 1,
    }
}

bitflags! {
    #[repr(C)]
    flags OstreeRepoCommitTraverseFlags: c_uint {
        const OSTREE_REPO_COMMIT_TRAVERSE_FLAG_NONE = 1,
    }
}

bitflags! {
    #[repr(C)]
    flags OstreeRepoListObjectsFlags: c_uint {
        const OSTREE_REPO_LIST_OBJECTS_LOOSE = 1,
        const OSTREE_REPO_LIST_OBJECTS_PACKED = 2,
        const OSTREE_REPO_LIST_OBJECTS_ALL = 4,
        const OSTREE_REPO_LIST_OBJECTS_NO_PARENTS = 8,
    }
}

bitflags! {
    #[repr(C)]
    flags OstreeRepoPullFlags: c_uint {
        const OSTREE_REPO_PULL_FLAGS_NONE = 0,
        const OSTREE_REPO_PULL_FLAGS_MIRROR = 1,
        const OSTREE_REPO_PULL_FLAGS_COMMIT_ONLY = 2,
        const OSTREE_REPO_PULL_FLAGS_UNTRUSTED = 4,
    }
}

bitflags! {
    #[repr(C)]
    flags OstreeSePolicyRestoreconFlags: c_uint {
        const OSTREE_SEPOLICY_RESTORECON_FLAGS_NONE = 0,
        const OSTREE_SEPOLICY_RESTORECON_FLAGS_ALLOW_NOLABEL = 1,
        const OSTREE_SEPOLICY_RESTORECON_FLAGS_KEEP_EXISTING = 2,
    }
}

bitflags! {
    #[repr(C)]
    flags OstreeSysrootSimpleWriteDeploymentFlags: c_uint {
        const OSTREE_SYSROOT_SIMPLE_WRITE_DEPLOYMENT_FLAGS_NONE = 0,
        const OSTREE_SYSROOT_SIMPLE_WRITE_DEPLOYMENT_FLAGS_RETAIN = 1,
        const OSTREE_SYSROOT_SIMPLE_WRITE_DEPLOYMENT_FLAGS_NOT_DEFAULT = 2,
        const OSTREE_SYSROOT_SIMPLE_WRITE_DEPLOYMENT_FLAGS_NO_CLEAN = 4,
    }
}

bitflags! {
    #[repr(C)]
    flags OstreeSysrootUpgraderFlags: c_uint {
        const OSTREE_SYSROOT_UPGRADER_FLAGS_IGNORE_UNCONFIGURED = 2,
    }
}

bitflags! {
    #[repr(C)]
    flags OstreeSysrootUpgraderPullFlags: c_uint {
        const OSTREE_SYSROOT_UPGRADER_PULL_FLAGS_NONE = 0,
        const OSTREE_SYSROOT_UPGRADER_PULL_FLAGS_ALLOW_OLDER = 1,
        const OSTREE_SYSROOT_UPGRADER_PULL_FLAGS_SYNTHETIC = 2,
    }
}

// Callbacks
pub type OstreeRepoCommitFilter = Option<unsafe extern "C" fn(*mut OstreeRepo, *const c_char, *mut gio::GFileInfo, gpointer) -> OstreeRepoCommitFilterResult>;
pub type OstreeRepoCommitModifierXattrCallback = Option<unsafe extern "C" fn(*mut OstreeRepo, *const c_char, *mut gio::GFileInfo, gpointer) -> *mut glib::GVariant>;

// Records
#[repr(C)]
pub struct OstreeAsyncProgressClass {
    pub parent_class: gobject::GObjectClass,
    pub changed: Option<unsafe extern "C" fn(*mut OstreeAsyncProgress, gpointer)>,
}

#[repr(C)]
pub struct OstreeBootloader(c_void);

#[repr(C)]
pub struct OstreeBootloaderGrub2(c_void);

#[repr(C)]
pub struct OstreeBootloaderInterface {
    pub g_iface: gobject::GTypeInterface,
    pub query: Option<unsafe extern "C" fn(*mut OstreeBootloader, *mut gboolean, *mut gio::GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub get_name: Option<unsafe extern "C" fn(*mut OstreeBootloader) -> *const c_char>,
    pub write_config: Option<unsafe extern "C" fn(*mut OstreeBootloader, c_int, *mut gio::GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub is_atomic: Option<unsafe extern "C" fn(*mut OstreeBootloader) -> gboolean>,
}

#[repr(C)]
pub struct OstreeBootloaderSyslinux(c_void);

#[repr(C)]
pub struct OstreeBootloaderUboot(c_void);

#[repr(C)]
pub struct OstreeChecksumInputStreamClass {
    pub parent_class: gio::GFilterInputStreamClass,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct OstreeChecksumInputStreamPrivate(c_void);

#[repr(C)]
pub struct OstreeCmdPrivateVTable {
    pub ostree_generate_grub2_config: Option<unsafe extern "C" fn(*mut OstreeSysroot, c_int, c_int, *mut gio::GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub ostree_static_delta_dump: Option<unsafe extern "C" fn(*mut OstreeRepo, *const c_char, *mut gio::GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub ostree_static_delta_query_exists: Option<unsafe extern "C" fn(*mut OstreeRepo, *const c_char, *mut gboolean, *mut gio::GCancellable, *mut *mut glib::GError) -> gboolean>,
    pub ostree_static_delta_delete: Option<unsafe extern "C" fn(*mut OstreeRepo, *const c_char, *mut gio::GCancellable, *mut *mut glib::GError) -> gboolean>,
}

#[repr(C)]
pub struct OstreeDiffItem {
    pub refcount: Volatile<c_int>,
    pub src: *mut gio::GFile,
    pub target: *mut gio::GFile,
    pub src_info: *mut gio::GFileInfo,
    pub target_info: *mut gio::GFileInfo,
    pub src_checksum: *mut c_char,
    pub target_checksum: *mut c_char,
}

#[repr(C)]
pub struct OstreeGpgVerifier(c_void);

#[repr(C)]
pub struct OstreeLibarchiveInputStream {
    pub parent_instance: gio::GInputStream,
    priv_: *mut OstreeLibarchiveInputStreamPrivate,
}

#[repr(C)]
pub struct OstreeLibarchiveInputStreamClass {
    pub parent_class: gio::GInputStreamClass,
    pub _g_reserved1: Option<unsafe extern "C" fn()>,
    pub _g_reserved2: Option<unsafe extern "C" fn()>,
    pub _g_reserved3: Option<unsafe extern "C" fn()>,
    pub _g_reserved4: Option<unsafe extern "C" fn()>,
    pub _g_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct OstreeLibarchiveInputStreamPrivate(c_void);

#[repr(C)]
pub struct OstreeLzmaCompressor(c_void);

#[repr(C)]
pub struct OstreeLzmaCompressorClass {
    pub parent_class: gobject::GObjectClass,
}

#[repr(C)]
pub struct OstreeLzmaDecompressor(c_void);

#[repr(C)]
pub struct OstreeLzmaDecompressorClass {
    pub parent_class: gobject::GObjectClass,
}

#[repr(C)]
pub struct OstreeMutableTreeClass {
    pub parent_class: gobject::GObjectClass,
}

#[repr(C)]
pub struct OstreeMutableTreeIter {
    pub in_files: gboolean,
    pub iter: glib::GHashTableIter,
}

#[repr(C)]
pub struct OstreeRepoCheckoutAtOptions {
    pub mode: OstreeRepoCheckoutMode,
    pub overwrite_mode: OstreeRepoCheckoutOverwriteMode,
    pub enable_uncompressed_cache: gboolean,
    pub enable_fsync: gboolean,
    pub process_whiteouts: gboolean,
    pub no_copy_fallback: gboolean,
    pub unused_bools: [gboolean; 7],
    pub subpath: *const c_char,
    pub devino_to_csum_cache: *mut OstreeRepoDevInoCache,
    pub unused_ints: [c_int; 6],
    pub unused_ptrs: [gpointer; 7],
}

#[repr(C)]
pub struct OstreeRepoCheckoutOptions {
    pub mode: OstreeRepoCheckoutMode,
    pub overwrite_mode: OstreeRepoCheckoutOverwriteMode,
    _truncated_record_marker: c_void,
    //enable_uncompressed_cache: guint: 1,
    //disable_fsync: guint: 1,
    //process_whiteouts: guint: 1,
    //no_copy_fallback: guint: 1,
    //reserved: guint: 28,
    //subpath: const char*,
    //devino_to_csum_cache: OstreeRepoDevInoCache*,
    //unused_uints: guint,
    //unused_ptrs: gpointer,
}

#[repr(C)]
pub struct OstreeRepoCommitModifier(c_void);

#[repr(C)]
pub struct OstreeRepoCommitTraverseIter {
    pub initialized: gboolean,
    pub dummy: [gpointer; 10],
    pub dummy_checksum_data: [c_char; 130],
}

#[repr(C)]
pub struct OstreeRepoDevInoCache(c_void);

#[repr(C)]
pub struct OstreeRepoExportArchiveOptions {
    _truncated_record_marker: c_void,
    //disable_xattrs: guint: 1,
    //reserved: guint: 31,
    //timestamp_secs: guint64,
    //unused_uint: guint,
    //path_prefix: char*,
    //unused_ptrs: gpointer,
}

#[repr(C)]
pub struct OstreeRepoFileClass {
    pub parent_class: gobject::GObjectClass,
}

#[repr(C)]
pub struct OstreeRepoFileEnumerator(c_void);

#[repr(C)]
pub struct OstreeRepoFileEnumeratorClass {
    pub parent_class: gio::GFileEnumeratorClass,
}

#[repr(C)]
pub struct OstreeRepoImportArchiveOptions {
    _truncated_record_marker: c_void,
    //ignore_unsupported_content: guint: 1,
    //autocreate_parents: guint: 1,
    //use_ostree_convention: guint: 1,
    //callback_with_entry_pathname: guint: 1,
    //reserved: guint: 28,
    //unused_uint: guint,
    //unused_ptrs: gpointer,
}

#[repr(C)]
pub struct OstreeRepoPruneOptions {
    pub flags: OstreeRepoPruneFlags,
    pub reachable: *mut glib::GHashTable,
    pub unused_bools: [gboolean; 6],
    pub unused_ints: [c_int; 6],
    pub unused_ptrs: [gpointer; 7],
}

#[repr(C)]
pub struct OstreeRepoTransactionStats {
    pub metadata_objects_total: c_uint,
    pub metadata_objects_written: c_uint,
    pub content_objects_total: c_uint,
    pub content_objects_written: c_uint,
    pub content_bytes_written: u64,
    pub padding1: u64,
    pub padding2: u64,
    pub padding3: u64,
    pub padding4: u64,
}

#[repr(C)]
pub struct OstreeRollsumMatches {
    pub from_rollsums: *mut glib::GHashTable,
    pub to_rollsums: *mut glib::GHashTable,
    pub crcmatches: c_uint,
    pub bufmatches: c_uint,
    pub total: c_uint,
    pub match_size: u64,
    pub matches: *mut glib::GPtrArray,
}

#[repr(C)]
pub struct OstreeTlsCertInteraction(c_void);

#[repr(C)]
pub struct OstreeTlsCertInteractionClass(c_void);

// Classes
#[repr(C)]
pub struct OstreeAsyncProgress(c_void);

#[repr(C)]
pub struct OstreeBootconfigParser(c_void);

#[repr(C)]
pub struct OstreeChecksumInputStream {
    pub parent_instance: gio::GFilterInputStream,
    priv_: *mut OstreeChecksumInputStreamPrivate,
}

#[repr(C)]
pub struct OstreeDeployment(c_void);

#[repr(C)]
pub struct OstreeGpgVerifyResult(c_void);

#[repr(C)]
pub struct OstreeMutableTree(c_void);

#[repr(C)]
pub struct OstreeRepo(c_void);

#[repr(C)]
pub struct OstreeRepoFile(c_void);

#[repr(C)]
pub struct OstreeSePolicy(c_void);

#[repr(C)]
pub struct OstreeSysroot(c_void);

#[repr(C)]
pub struct OstreeSysrootUpgrader(c_void);

extern "C" {

    //=========================================================================
    // OstreeDiffItem
    //=========================================================================
    pub fn ostree_diff_item_get_type() -> GType;
    pub fn ostree_diff_item_ref(diffitem: *mut OstreeDiffItem) -> *mut OstreeDiffItem;
    pub fn ostree_diff_item_unref(diffitem: *mut OstreeDiffItem);

    //=========================================================================
    // OstreeRepoCommitModifier
    //=========================================================================
    pub fn ostree_repo_commit_modifier_get_type() -> GType;
    pub fn ostree_repo_commit_modifier_new(flags: OstreeRepoCommitModifierFlags, commit_filter: OstreeRepoCommitFilter, user_data: gpointer, destroy_notify: glib::GDestroyNotify) -> *mut OstreeRepoCommitModifier;
    pub fn ostree_repo_commit_modifier_ref(modifier: *mut OstreeRepoCommitModifier) -> *mut OstreeRepoCommitModifier;
    pub fn ostree_repo_commit_modifier_set_devino_cache(modifier: *mut OstreeRepoCommitModifier, cache: *mut OstreeRepoDevInoCache);
    pub fn ostree_repo_commit_modifier_set_sepolicy(modifier: *mut OstreeRepoCommitModifier, sepolicy: *mut OstreeSePolicy);
    pub fn ostree_repo_commit_modifier_set_xattr_callback(modifier: *mut OstreeRepoCommitModifier, callback: OstreeRepoCommitModifierXattrCallback, destroy: glib::GDestroyNotify, user_data: gpointer);
    pub fn ostree_repo_commit_modifier_unref(modifier: *mut OstreeRepoCommitModifier);

    //=========================================================================
    // OstreeRepoCommitTraverseIter
    //=========================================================================
    pub fn ostree_repo_commit_traverse_iter_clear(iter: *mut OstreeRepoCommitTraverseIter);
    pub fn ostree_repo_commit_traverse_iter_get_dir(iter: *mut OstreeRepoCommitTraverseIter, out_name: *mut *mut c_char, out_content_checksum: *mut *mut c_char, out_meta_checksum: *mut *mut c_char);
    pub fn ostree_repo_commit_traverse_iter_get_file(iter: *mut OstreeRepoCommitTraverseIter, out_name: *mut *mut c_char, out_checksum: *mut *mut c_char);
    pub fn ostree_repo_commit_traverse_iter_init_commit(iter: *mut OstreeRepoCommitTraverseIter, repo: *mut OstreeRepo, commit: *mut glib::GVariant, flags: OstreeRepoCommitTraverseFlags, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_commit_traverse_iter_init_dirtree(iter: *mut OstreeRepoCommitTraverseIter, repo: *mut OstreeRepo, dirtree: *mut glib::GVariant, flags: OstreeRepoCommitTraverseFlags, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_commit_traverse_iter_next(iter: *mut OstreeRepoCommitTraverseIter, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> OstreeRepoCommitIterResult;
    pub fn ostree_repo_commit_traverse_iter_cleanup(p: *mut c_void);

    //=========================================================================
    // OstreeRepoDevInoCache
    //=========================================================================
    pub fn ostree_repo_devino_cache_get_type() -> GType;
    pub fn ostree_repo_devino_cache_new() -> *mut OstreeRepoDevInoCache;
    pub fn ostree_repo_devino_cache_ref(cache: *mut OstreeRepoDevInoCache) -> *mut OstreeRepoDevInoCache;
    pub fn ostree_repo_devino_cache_unref(cache: *mut OstreeRepoDevInoCache);

    //=========================================================================
    // OstreeRepoTransactionStats
    //=========================================================================
    pub fn ostree_repo_transaction_stats_get_type() -> GType;

    //=========================================================================
    // OstreeAsyncProgress
    //=========================================================================
    pub fn ostree_async_progress_get_type() -> GType;
    pub fn ostree_async_progress_new() -> *mut OstreeAsyncProgress;
    pub fn ostree_async_progress_new_and_connect(changed: *mut gpointer, user_data: gpointer) -> *mut OstreeAsyncProgress;
    pub fn ostree_async_progress_finish(self_: *mut OstreeAsyncProgress);
    pub fn ostree_async_progress_get_status(self_: *mut OstreeAsyncProgress) -> *mut c_char;
    pub fn ostree_async_progress_get_uint(self_: *mut OstreeAsyncProgress, key: *const c_char) -> c_uint;
    pub fn ostree_async_progress_get_uint64(self_: *mut OstreeAsyncProgress, key: *const c_char) -> u64;
    pub fn ostree_async_progress_set_status(self_: *mut OstreeAsyncProgress, status: *const c_char);
    pub fn ostree_async_progress_set_uint(self_: *mut OstreeAsyncProgress, key: *const c_char, value: c_uint);
    pub fn ostree_async_progress_set_uint64(self_: *mut OstreeAsyncProgress, key: *const c_char, value: u64);

    //=========================================================================
    // OstreeBootconfigParser
    //=========================================================================
    pub fn ostree_bootconfig_parser_get_type() -> GType;
    pub fn ostree_bootconfig_parser_new() -> *mut OstreeBootconfigParser;
    pub fn ostree_bootconfig_parser_clone(self_: *mut OstreeBootconfigParser) -> *mut OstreeBootconfigParser;
    pub fn ostree_bootconfig_parser_get(self_: *mut OstreeBootconfigParser, key: *const c_char) -> *const c_char;
    pub fn ostree_bootconfig_parser_parse(self_: *mut OstreeBootconfigParser, path: *mut gio::GFile, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_bootconfig_parser_parse_at(self_: *mut OstreeBootconfigParser, dfd: c_int, path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_bootconfig_parser_set(self_: *mut OstreeBootconfigParser, key: *const c_char, value: *const c_char);
    pub fn ostree_bootconfig_parser_write(self_: *mut OstreeBootconfigParser, output: *mut gio::GFile, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_bootconfig_parser_write_at(self_: *mut OstreeBootconfigParser, dfd: c_int, path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // OstreeChecksumInputStream
    //=========================================================================
    pub fn ostree_checksum_input_stream_get_type() -> GType;
    pub fn ostree_checksum_input_stream_new(stream: *mut gio::GInputStream, checksum: *mut glib::GChecksum) -> *mut OstreeChecksumInputStream;

    //=========================================================================
    // OstreeDeployment
    //=========================================================================
    pub fn ostree_deployment_get_type() -> GType;
    pub fn ostree_deployment_new(index: c_int, osname: *const c_char, csum: *const c_char, deployserial: c_int, bootcsum: *const c_char, bootserial: c_int) -> *mut OstreeDeployment;
    pub fn ostree_deployment_hash(v: gconstpointer) -> c_uint;
    pub fn ostree_deployment_unlocked_state_to_string(state: OstreeDeploymentUnlockedState) -> *const c_char;
    pub fn ostree_deployment_clone(self_: *mut OstreeDeployment) -> *mut OstreeDeployment;
    pub fn ostree_deployment_equal(ap: gconstpointer, bp: gconstpointer) -> gboolean;
    pub fn ostree_deployment_get_bootconfig(self_: *mut OstreeDeployment) -> *mut OstreeBootconfigParser;
    pub fn ostree_deployment_get_bootcsum(self_: *mut OstreeDeployment) -> *const c_char;
    pub fn ostree_deployment_get_bootserial(self_: *mut OstreeDeployment) -> c_int;
    pub fn ostree_deployment_get_csum(self_: *mut OstreeDeployment) -> *const c_char;
    pub fn ostree_deployment_get_deployserial(self_: *mut OstreeDeployment) -> c_int;
    pub fn ostree_deployment_get_index(self_: *mut OstreeDeployment) -> c_int;
    pub fn ostree_deployment_get_origin(self_: *mut OstreeDeployment) -> *mut glib::GKeyFile;
    pub fn ostree_deployment_get_origin_relpath(self_: *mut OstreeDeployment) -> *mut c_char;
    pub fn ostree_deployment_get_osname(self_: *mut OstreeDeployment) -> *const c_char;
    pub fn ostree_deployment_get_unlocked(self_: *mut OstreeDeployment) -> OstreeDeploymentUnlockedState;
    pub fn ostree_deployment_set_bootconfig(self_: *mut OstreeDeployment, bootconfig: *mut OstreeBootconfigParser);
    pub fn ostree_deployment_set_bootserial(self_: *mut OstreeDeployment, index: c_int);
    pub fn ostree_deployment_set_index(self_: *mut OstreeDeployment, index: c_int);
    pub fn ostree_deployment_set_origin(self_: *mut OstreeDeployment, origin: *mut glib::GKeyFile);

    //=========================================================================
    // OstreeGpgVerifyResult
    //=========================================================================
    pub fn ostree_gpg_verify_result_get_type() -> GType;
    pub fn ostree_gpg_verify_result_describe_variant(variant: *mut glib::GVariant, output_buffer: *mut glib::GString, line_prefix: *const c_char, flags: OstreeGpgSignatureFormatFlags);
    pub fn ostree_gpg_verify_result_count_all(result: *mut OstreeGpgVerifyResult) -> c_uint;
    pub fn ostree_gpg_verify_result_count_valid(result: *mut OstreeGpgVerifyResult) -> c_uint;
    pub fn ostree_gpg_verify_result_describe(result: *mut OstreeGpgVerifyResult, signature_index: c_uint, output_buffer: *mut glib::GString, line_prefix: *const c_char, flags: OstreeGpgSignatureFormatFlags);
    pub fn ostree_gpg_verify_result_get(result: *mut OstreeGpgVerifyResult, signature_index: c_uint, attrs: *mut OstreeGpgSignatureAttr, n_attrs: c_uint) -> *mut glib::GVariant;
    pub fn ostree_gpg_verify_result_get_all(result: *mut OstreeGpgVerifyResult, signature_index: c_uint) -> *mut glib::GVariant;
    pub fn ostree_gpg_verify_result_lookup(result: *mut OstreeGpgVerifyResult, key_id: *const c_char, out_signature_index: *mut c_uint) -> gboolean;
    pub fn ostree_gpg_verify_result_require_valid_signature(result: *mut OstreeGpgVerifyResult, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // OstreeMutableTree
    //=========================================================================
    pub fn ostree_mutable_tree_get_type() -> GType;
    pub fn ostree_mutable_tree_new() -> *mut OstreeMutableTree;
    pub fn ostree_mutable_tree_ensure_dir(self_: *mut OstreeMutableTree, name: *const c_char, out_subdir: *mut *mut OstreeMutableTree, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_mutable_tree_ensure_parent_dirs(self_: *mut OstreeMutableTree, split_path: *mut glib::GPtrArray, metadata_checksum: *const c_char, out_parent: *mut *mut OstreeMutableTree, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_mutable_tree_get_contents_checksum(self_: *mut OstreeMutableTree) -> *const c_char;
    pub fn ostree_mutable_tree_get_files(self_: *mut OstreeMutableTree) -> *mut glib::GHashTable;
    pub fn ostree_mutable_tree_get_metadata_checksum(self_: *mut OstreeMutableTree) -> *const c_char;
    pub fn ostree_mutable_tree_get_subdirs(self_: *mut OstreeMutableTree) -> *mut glib::GHashTable;
    pub fn ostree_mutable_tree_lookup(self_: *mut OstreeMutableTree, name: *const c_char, out_file_checksum: *mut *mut c_char, out_subdir: *mut *mut OstreeMutableTree, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_mutable_tree_replace_file(self_: *mut OstreeMutableTree, name: *const c_char, checksum: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_mutable_tree_set_contents_checksum(self_: *mut OstreeMutableTree, checksum: *const c_char);
    pub fn ostree_mutable_tree_set_metadata_checksum(self_: *mut OstreeMutableTree, checksum: *const c_char);
    pub fn ostree_mutable_tree_walk(self_: *mut OstreeMutableTree, split_path: *mut glib::GPtrArray, start: c_uint, out_subdir: *mut *mut OstreeMutableTree, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // OstreeRepo
    //=========================================================================
    pub fn ostree_repo_get_type() -> GType;
    pub fn ostree_repo_new(path: *mut gio::GFile) -> *mut OstreeRepo;
    pub fn ostree_repo_new_default() -> *mut OstreeRepo;
    pub fn ostree_repo_new_for_sysroot_path(repo_path: *mut gio::GFile, sysroot_path: *mut gio::GFile) -> *mut OstreeRepo;
    pub fn ostree_repo_mode_from_string(mode: *const c_char, out_mode: *mut OstreeRepoMode, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_pull_default_console_progress_changed(progress: *mut OstreeAsyncProgress, user_data: gpointer);
    pub fn ostree_repo_traverse_new_reachable() -> *mut glib::GHashTable;
    pub fn ostree_repo_abort_transaction(self_: *mut OstreeRepo, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_add_gpg_signature_summary(self_: *mut OstreeRepo, key_id: *mut *mut c_char, homedir: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_append_gpg_signature(self_: *mut OstreeRepo, commit_checksum: *const c_char, signature_bytes: *mut glib::GBytes, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_checkout_at(self_: *mut OstreeRepo, options: *mut OstreeRepoCheckoutAtOptions, destination_dfd: c_int, destination_path: *const c_char, commit: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_checkout_gc(self_: *mut OstreeRepo, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_checkout_tree(self_: *mut OstreeRepo, mode: OstreeRepoCheckoutMode, overwrite_mode: OstreeRepoCheckoutOverwriteMode, destination: *mut gio::GFile, source: *mut OstreeRepoFile, source_info: *mut gio::GFileInfo, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_checkout_tree_at(self_: *mut OstreeRepo, options: *mut OstreeRepoCheckoutOptions, destination_dfd: c_int, destination_path: *const c_char, commit: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_commit_transaction(self_: *mut OstreeRepo, out_stats: *mut OstreeRepoTransactionStats, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_copy_config(self_: *mut OstreeRepo) -> *mut glib::GKeyFile;
    pub fn ostree_repo_create(self_: *mut OstreeRepo, mode: OstreeRepoMode, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_delete_object(self_: *mut OstreeRepo, objtype: OstreeObjectType, sha256: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_export_tree_to_archive(self_: *mut OstreeRepo, opts: *mut OstreeRepoExportArchiveOptions, root: *mut OstreeRepoFile, archive: *mut c_void, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_get_config(self_: *mut OstreeRepo) -> *mut glib::GKeyFile;
    pub fn ostree_repo_get_dfd(self_: *mut OstreeRepo) -> c_int;
    pub fn ostree_repo_get_disable_fsync(self_: *mut OstreeRepo) -> gboolean;
    pub fn ostree_repo_get_mode(self_: *mut OstreeRepo) -> OstreeRepoMode;
    pub fn ostree_repo_get_parent(self_: *mut OstreeRepo) -> *mut OstreeRepo;
    pub fn ostree_repo_get_path(self_: *mut OstreeRepo) -> *mut gio::GFile;
    pub fn ostree_repo_get_remote_boolean_option(self_: *mut OstreeRepo, remote_name: *const c_char, option_name: *const c_char, default_value: gboolean, out_value: *mut gboolean, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_get_remote_list_option(self_: *mut OstreeRepo, remote_name: *const c_char, option_name: *const c_char, out_value: *mut *mut *mut c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_get_remote_option(self_: *mut OstreeRepo, remote_name: *const c_char, option_name: *const c_char, default_value: *const c_char, out_value: *mut *mut c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_gpg_verify_data(self_: *mut OstreeRepo, remote_name: *const c_char, data: *mut glib::GBytes, signatures: *mut glib::GBytes, keyringdir: *mut gio::GFile, extra_keyring: *mut gio::GFile, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut OstreeGpgVerifyResult;
    pub fn ostree_repo_has_object(self_: *mut OstreeRepo, objtype: OstreeObjectType, checksum: *const c_char, out_have_object: *mut gboolean, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_import_archive_to_mtree(self_: *mut OstreeRepo, opts: *mut OstreeRepoImportArchiveOptions, archive: *mut c_void, mtree: *mut OstreeMutableTree, modifier: *mut OstreeRepoCommitModifier, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_import_object_from(self_: *mut OstreeRepo, source: *mut OstreeRepo, objtype: OstreeObjectType, checksum: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_import_object_from_with_trust(self_: *mut OstreeRepo, source: *mut OstreeRepo, objtype: OstreeObjectType, checksum: *const c_char, trusted: gboolean, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_is_system(repo: *mut OstreeRepo) -> gboolean;
    pub fn ostree_repo_is_writable(self_: *mut OstreeRepo, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_list_commit_objects_starting_with(self_: *mut OstreeRepo, start: *const c_char, out_commits: *mut *mut glib::GHashTable, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_list_objects(self_: *mut OstreeRepo, flags: OstreeRepoListObjectsFlags, out_objects: *mut *mut glib::GHashTable, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_list_refs(self_: *mut OstreeRepo, refspec_prefix: *const c_char, out_all_refs: *mut *mut glib::GHashTable, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_list_refs_ext(self_: *mut OstreeRepo, refspec_prefix: *const c_char, out_all_refs: *mut *mut glib::GHashTable, flags: OstreeRepoListRefsExtFlags, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_list_static_delta_names(self_: *mut OstreeRepo, out_deltas: *mut *mut glib::GPtrArray, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_load_commit(self_: *mut OstreeRepo, checksum: *const c_char, out_commit: *mut *mut glib::GVariant, out_state: *mut OstreeRepoCommitState, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_load_file(self_: *mut OstreeRepo, checksum: *const c_char, out_input: *mut *mut gio::GInputStream, out_file_info: *mut *mut gio::GFileInfo, out_xattrs: *mut *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_load_object_stream(self_: *mut OstreeRepo, objtype: OstreeObjectType, checksum: *const c_char, out_input: *mut *mut gio::GInputStream, out_size: *mut u64, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_load_variant(self_: *mut OstreeRepo, objtype: OstreeObjectType, sha256: *const c_char, out_variant: *mut *mut glib::GVariant, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_load_variant_if_exists(self_: *mut OstreeRepo, objtype: OstreeObjectType, sha256: *const c_char, out_variant: *mut *mut glib::GVariant, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_open(self_: *mut OstreeRepo, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_prepare_transaction(self_: *mut OstreeRepo, out_transaction_resume: *mut gboolean, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_prune(self_: *mut OstreeRepo, flags: OstreeRepoPruneFlags, depth: c_int, out_objects_total: *mut c_int, out_objects_pruned: *mut c_int, out_pruned_object_size_total: *mut u64, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_prune_from_reachable(self_: *mut OstreeRepo, options: *mut OstreeRepoPruneOptions, out_objects_total: *mut c_int, out_objects_pruned: *mut c_int, out_pruned_object_size_total: *mut u64, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_prune_static_deltas(self_: *mut OstreeRepo, commit: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_pull(self_: *mut OstreeRepo, remote_name: *const c_char, refs_to_fetch: *mut *mut c_char, flags: OstreeRepoPullFlags, progress: *mut OstreeAsyncProgress, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_pull_one_dir(self_: *mut OstreeRepo, remote_name: *const c_char, dir_to_pull: *const c_char, refs_to_fetch: *mut *mut c_char, flags: OstreeRepoPullFlags, progress: *mut OstreeAsyncProgress, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_pull_with_options(self_: *mut OstreeRepo, remote_name_or_baseurl: *const c_char, options: *mut glib::GVariant, progress: *mut OstreeAsyncProgress, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_query_object_storage_size(self_: *mut OstreeRepo, objtype: OstreeObjectType, sha256: *const c_char, out_size: *mut u64, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_read_commit(self_: *mut OstreeRepo, ref_: *const c_char, out_root: *mut *mut gio::GFile, out_commit: *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_read_commit_detached_metadata(self_: *mut OstreeRepo, checksum: *const c_char, out_metadata: *mut *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_regenerate_summary(self_: *mut OstreeRepo, additional_metadata: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_reload_config(self_: *mut OstreeRepo, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_remote_add(self_: *mut OstreeRepo, name: *const c_char, url: *const c_char, options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_remote_change(self_: *mut OstreeRepo, sysroot: *mut gio::GFile, changeop: OstreeRepoRemoteChange, name: *const c_char, url: *const c_char, options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_remote_delete(self_: *mut OstreeRepo, name: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_remote_fetch_summary(self_: *mut OstreeRepo, name: *const c_char, out_summary: *mut *mut glib::GBytes, out_signatures: *mut *mut glib::GBytes, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_remote_fetch_summary_with_options(self_: *mut OstreeRepo, name: *const c_char, options: *mut glib::GVariant, out_summary: *mut *mut glib::GBytes, out_signatures: *mut *mut glib::GBytes, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_remote_get_gpg_verify(self_: *mut OstreeRepo, name: *const c_char, out_gpg_verify: *mut gboolean, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_remote_get_gpg_verify_summary(self_: *mut OstreeRepo, name: *const c_char, out_gpg_verify_summary: *mut gboolean, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_remote_get_url(self_: *mut OstreeRepo, name: *const c_char, out_url: *mut *mut c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_remote_gpg_import(self_: *mut OstreeRepo, name: *const c_char, source_stream: *mut gio::GInputStream, key_ids: *mut *mut c_char, out_imported: *mut c_uint, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_remote_list(self_: *mut OstreeRepo, out_n_remotes: *mut c_uint) -> *mut *mut c_char;
    pub fn ostree_repo_remote_list_refs(self_: *mut OstreeRepo, remote_name: *const c_char, out_all_refs: *mut *mut glib::GHashTable, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_resolve_rev(self_: *mut OstreeRepo, refspec: *const c_char, allow_noent: gboolean, out_rev: *mut *mut c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_resolve_rev_ext(self_: *mut OstreeRepo, refspec: *const c_char, allow_noent: gboolean, flags: OstreeRepoResolveRevExtFlags, out_rev: *mut *mut c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_scan_hardlinks(self_: *mut OstreeRepo, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_set_cache_dir(self_: *mut OstreeRepo, dfd: c_int, path: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_set_disable_fsync(self_: *mut OstreeRepo, disable_fsync: gboolean);
    pub fn ostree_repo_set_ref_immediate(self_: *mut OstreeRepo, remote: *const c_char, ref_: *const c_char, checksum: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_sign_commit(self_: *mut OstreeRepo, commit_checksum: *const c_char, key_id: *const c_char, homedir: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_sign_delta(self_: *mut OstreeRepo, from_commit: *const c_char, to_commit: *const c_char, key_id: *const c_char, homedir: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_static_delta_execute_offline(self_: *mut OstreeRepo, dir_or_file: *mut gio::GFile, skip_validation: gboolean, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_static_delta_generate(self_: *mut OstreeRepo, opt: OstreeStaticDeltaGenerateOpt, from: *const c_char, to: *const c_char, metadata: *mut glib::GVariant, params: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_transaction_set_ref(self_: *mut OstreeRepo, remote: *const c_char, ref_: *const c_char, checksum: *const c_char);
    pub fn ostree_repo_transaction_set_refspec(self_: *mut OstreeRepo, refspec: *const c_char, checksum: *const c_char);
    pub fn ostree_repo_traverse_commit(repo: *mut OstreeRepo, commit_checksum: *const c_char, maxdepth: c_int, out_reachable: *mut *mut glib::GHashTable, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_traverse_commit_union(repo: *mut OstreeRepo, commit_checksum: *const c_char, maxdepth: c_int, inout_reachable: *mut glib::GHashTable, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_verify_commit(self_: *mut OstreeRepo, commit_checksum: *const c_char, keyringdir: *mut gio::GFile, extra_keyring: *mut gio::GFile, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_verify_commit_ext(self_: *mut OstreeRepo, commit_checksum: *const c_char, keyringdir: *mut gio::GFile, extra_keyring: *mut gio::GFile, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut OstreeGpgVerifyResult;
    pub fn ostree_repo_verify_commit_for_remote(self_: *mut OstreeRepo, commit_checksum: *const c_char, remote_name: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut OstreeGpgVerifyResult;
    pub fn ostree_repo_verify_summary(self_: *mut OstreeRepo, remote_name: *const c_char, summary: *mut glib::GBytes, signatures: *mut glib::GBytes, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut OstreeGpgVerifyResult;
    pub fn ostree_repo_write_archive_to_mtree(self_: *mut OstreeRepo, archive: *mut gio::GFile, mtree: *mut OstreeMutableTree, modifier: *mut OstreeRepoCommitModifier, autocreate_parents: gboolean, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_write_commit(self_: *mut OstreeRepo, parent: *const c_char, subject: *const c_char, body: *const c_char, metadata: *mut glib::GVariant, root: *mut OstreeRepoFile, out_commit: *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_write_commit_detached_metadata(self_: *mut OstreeRepo, checksum: *const c_char, metadata: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_write_commit_with_time(self_: *mut OstreeRepo, parent: *const c_char, subject: *const c_char, body: *const c_char, metadata: *mut glib::GVariant, root: *mut OstreeRepoFile, time: u64, out_commit: *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_write_config(self_: *mut OstreeRepo, new_config: *mut glib::GKeyFile, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_write_content(self_: *mut OstreeRepo, expected_checksum: *const c_char, object_input: *mut gio::GInputStream, length: u64, out_csum: *mut *mut [u8; 32], cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_write_content_async(self_: *mut OstreeRepo, expected_checksum: *const c_char, object: *mut gio::GInputStream, length: u64, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn ostree_repo_write_content_finish(self_: *mut OstreeRepo, result: *mut gio::GAsyncResult, out_csum: *mut *mut u8, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_write_content_trusted(self_: *mut OstreeRepo, checksum: *const c_char, object_input: *mut gio::GInputStream, length: u64, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_write_dfd_to_mtree(self_: *mut OstreeRepo, dfd: c_int, path: *const c_char, mtree: *mut OstreeMutableTree, modifier: *mut OstreeRepoCommitModifier, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_write_directory_to_mtree(self_: *mut OstreeRepo, dir: *mut gio::GFile, mtree: *mut OstreeMutableTree, modifier: *mut OstreeRepoCommitModifier, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_write_metadata(self_: *mut OstreeRepo, objtype: OstreeObjectType, expected_checksum: *const c_char, object: *mut glib::GVariant, out_csum: *mut *mut [u8; 32], cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_write_metadata_async(self_: *mut OstreeRepo, objtype: OstreeObjectType, expected_checksum: *const c_char, object: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn ostree_repo_write_metadata_finish(self_: *mut OstreeRepo, result: *mut gio::GAsyncResult, out_csum: *mut *mut u8, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_write_metadata_stream_trusted(self_: *mut OstreeRepo, objtype: OstreeObjectType, checksum: *const c_char, object_input: *mut gio::GInputStream, length: u64, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_write_metadata_trusted(self_: *mut OstreeRepo, objtype: OstreeObjectType, checksum: *const c_char, variant: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_write_mtree(self_: *mut OstreeRepo, mtree: *mut OstreeMutableTree, out_file: *mut *mut gio::GFile, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // OstreeRepoFile
    //=========================================================================
    pub fn ostree_repo_file_get_type() -> GType;
    pub fn ostree_repo_file_ensure_resolved(self_: *mut OstreeRepoFile, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_file_get_checksum(self_: *mut OstreeRepoFile) -> *const c_char;
    pub fn ostree_repo_file_get_repo(self_: *mut OstreeRepoFile) -> *mut OstreeRepo;
    pub fn ostree_repo_file_get_root(self_: *mut OstreeRepoFile) -> *mut OstreeRepoFile;
    pub fn ostree_repo_file_get_xattrs(self_: *mut OstreeRepoFile, out_xattrs: *mut *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_file_tree_find_child(self_: *mut OstreeRepoFile, name: *const c_char, is_dir: *mut gboolean, out_container: *mut *mut glib::GVariant) -> c_int;
    pub fn ostree_repo_file_tree_get_contents(self_: *mut OstreeRepoFile) -> *mut glib::GVariant;
    pub fn ostree_repo_file_tree_get_contents_checksum(self_: *mut OstreeRepoFile) -> *const c_char;
    pub fn ostree_repo_file_tree_get_metadata(self_: *mut OstreeRepoFile) -> *mut glib::GVariant;
    pub fn ostree_repo_file_tree_get_metadata_checksum(self_: *mut OstreeRepoFile) -> *const c_char;
    pub fn ostree_repo_file_tree_query_child(self_: *mut OstreeRepoFile, n: c_int, attributes: *const c_char, flags: gio::GFileQueryInfoFlags, out_info: *mut *mut gio::GFileInfo, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_repo_file_tree_set_metadata(self_: *mut OstreeRepoFile, checksum: *const c_char, metadata: *mut glib::GVariant);

    //=========================================================================
    // OstreeSePolicy
    //=========================================================================
    pub fn ostree_sepolicy_get_type() -> GType;
    pub fn ostree_sepolicy_new(path: *mut gio::GFile, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut OstreeSePolicy;
    pub fn ostree_sepolicy_fscreatecon_cleanup(unused: *mut *mut c_void);
    pub fn ostree_sepolicy_get_csum(self_: *mut OstreeSePolicy) -> *const c_char;
    pub fn ostree_sepolicy_get_label(self_: *mut OstreeSePolicy, relpath: *const c_char, unix_mode: u32, out_label: *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_sepolicy_get_name(self_: *mut OstreeSePolicy) -> *const c_char;
    pub fn ostree_sepolicy_get_path(self_: *mut OstreeSePolicy) -> *mut gio::GFile;
    pub fn ostree_sepolicy_restorecon(self_: *mut OstreeSePolicy, path: *const c_char, info: *mut gio::GFileInfo, target: *mut gio::GFile, flags: OstreeSePolicyRestoreconFlags, out_new_label: *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_sepolicy_setfscreatecon(self_: *mut OstreeSePolicy, path: *const c_char, mode: u32, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // OstreeSysroot
    //=========================================================================
    pub fn ostree_sysroot_get_type() -> GType;
    pub fn ostree_sysroot_new(path: *mut gio::GFile) -> *mut OstreeSysroot;
    pub fn ostree_sysroot_new_default() -> *mut OstreeSysroot;
    pub fn ostree_sysroot_get_deployment_origin_path(deployment_path: *mut gio::GFile) -> *mut gio::GFile;
    pub fn ostree_sysroot_cleanup(self_: *mut OstreeSysroot, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_sysroot_deploy_tree(self_: *mut OstreeSysroot, osname: *const c_char, revision: *const c_char, origin: *mut glib::GKeyFile, provided_merge_deployment: *mut OstreeDeployment, override_kernel_argv: *mut *mut c_char, out_new_deployment: *mut *mut OstreeDeployment, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_sysroot_deployment_set_kargs(self_: *mut OstreeSysroot, deployment: *mut OstreeDeployment, new_kargs: *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_sysroot_deployment_set_mutable(self_: *mut OstreeSysroot, deployment: *mut OstreeDeployment, is_mutable: gboolean, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_sysroot_deployment_unlock(self_: *mut OstreeSysroot, deployment: *mut OstreeDeployment, unlocked_state: OstreeDeploymentUnlockedState, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_sysroot_ensure_initialized(self_: *mut OstreeSysroot, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_sysroot_get_booted_deployment(self_: *mut OstreeSysroot) -> *mut OstreeDeployment;
    pub fn ostree_sysroot_get_bootversion(self_: *mut OstreeSysroot) -> c_int;
    pub fn ostree_sysroot_get_deployment_directory(self_: *mut OstreeSysroot, deployment: *mut OstreeDeployment) -> *mut gio::GFile;
    pub fn ostree_sysroot_get_deployment_dirpath(self_: *mut OstreeSysroot, deployment: *mut OstreeDeployment) -> *mut c_char;
    pub fn ostree_sysroot_get_deployments(self_: *mut OstreeSysroot) -> *mut glib::GPtrArray;
    pub fn ostree_sysroot_get_fd(self_: *mut OstreeSysroot) -> c_int;
    pub fn ostree_sysroot_get_merge_deployment(self_: *mut OstreeSysroot, osname: *const c_char) -> *mut OstreeDeployment;
    pub fn ostree_sysroot_get_path(self_: *mut OstreeSysroot) -> *mut gio::GFile;
    pub fn ostree_sysroot_get_repo(self_: *mut OstreeSysroot, out_repo: *mut *mut OstreeRepo, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_sysroot_get_subbootversion(self_: *mut OstreeSysroot) -> c_int;
    pub fn ostree_sysroot_init_osname(self_: *mut OstreeSysroot, osname: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_sysroot_load(self_: *mut OstreeSysroot, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_sysroot_load_if_changed(self_: *mut OstreeSysroot, out_changed: *mut gboolean, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_sysroot_lock(self_: *mut OstreeSysroot, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_sysroot_lock_async(self_: *mut OstreeSysroot, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn ostree_sysroot_lock_finish(self_: *mut OstreeSysroot, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_sysroot_origin_new_from_refspec(self_: *mut OstreeSysroot, refspec: *const c_char) -> *mut glib::GKeyFile;
    pub fn ostree_sysroot_prepare_cleanup(self_: *mut OstreeSysroot, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_sysroot_simple_write_deployment(sysroot: *mut OstreeSysroot, osname: *const c_char, new_deployment: *mut OstreeDeployment, merge_deployment: *mut OstreeDeployment, flags: OstreeSysrootSimpleWriteDeploymentFlags, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_sysroot_try_lock(self_: *mut OstreeSysroot, out_acquired: *mut gboolean, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_sysroot_unload(self_: *mut OstreeSysroot);
    pub fn ostree_sysroot_unlock(self_: *mut OstreeSysroot);
    pub fn ostree_sysroot_write_deployments(self_: *mut OstreeSysroot, new_deployments: *mut glib::GPtrArray, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_sysroot_write_origin_file(sysroot: *mut OstreeSysroot, deployment: *mut OstreeDeployment, new_origin: *mut glib::GKeyFile, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // OstreeSysrootUpgrader
    //=========================================================================
    pub fn ostree_sysroot_upgrader_get_type() -> GType;
    pub fn ostree_sysroot_upgrader_new(sysroot: *mut OstreeSysroot, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut OstreeSysrootUpgrader;
    pub fn ostree_sysroot_upgrader_new_for_os(sysroot: *mut OstreeSysroot, osname: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut OstreeSysrootUpgrader;
    pub fn ostree_sysroot_upgrader_new_for_os_with_flags(sysroot: *mut OstreeSysroot, osname: *const c_char, flags: OstreeSysrootUpgraderFlags, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut OstreeSysrootUpgrader;
    pub fn ostree_sysroot_upgrader_check_timestamps(repo: *mut OstreeRepo, from_rev: *const c_char, to_rev: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_sysroot_upgrader_deploy(self_: *mut OstreeSysrootUpgrader, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_sysroot_upgrader_dup_origin(self_: *mut OstreeSysrootUpgrader) -> *mut glib::GKeyFile;
    pub fn ostree_sysroot_upgrader_get_origin(self_: *mut OstreeSysrootUpgrader) -> *mut glib::GKeyFile;
    pub fn ostree_sysroot_upgrader_get_origin_description(self_: *mut OstreeSysrootUpgrader) -> *mut c_char;
    pub fn ostree_sysroot_upgrader_pull(self_: *mut OstreeSysrootUpgrader, flags: OstreeRepoPullFlags, upgrader_flags: OstreeSysrootUpgraderPullFlags, progress: *mut OstreeAsyncProgress, out_changed: *mut gboolean, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_sysroot_upgrader_pull_one_dir(self_: *mut OstreeSysrootUpgrader, dir_to_pull: *const c_char, flags: OstreeRepoPullFlags, upgrader_flags: OstreeSysrootUpgraderPullFlags, progress: *mut OstreeAsyncProgress, out_changed: *mut gboolean, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_sysroot_upgrader_set_origin(self_: *mut OstreeSysrootUpgrader, origin: *mut glib::GKeyFile, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn ostree_checksum_b64_from_bytes(csum: *mut [u8; 32]) -> *mut c_char;
    pub fn ostree_checksum_b64_inplace_from_bytes(csum: *mut [u8; 32], buf: *mut c_char);
    pub fn ostree_checksum_b64_inplace_to_bytes(checksum: *mut [c_char; 32], buf: *mut u8);
    pub fn ostree_checksum_b64_to_bytes(checksum: *const c_char) -> *mut [u8; 32];
    pub fn ostree_checksum_bytes_peek(bytes: *mut glib::GVariant) -> *mut [u8; 32];
    pub fn ostree_checksum_bytes_peek_validate(bytes: *mut glib::GVariant, error: *mut *mut glib::GError) -> *mut [u8; 32];
    pub fn ostree_checksum_file(f: *mut gio::GFile, objtype: OstreeObjectType, out_csum: *mut *mut [u8; 32], cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_checksum_file_async(f: *mut gio::GFile, objtype: OstreeObjectType, io_priority: c_int, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn ostree_checksum_file_async_finish(f: *mut gio::GFile, result: *mut gio::GAsyncResult, out_csum: *mut *mut [u8; 32], error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_checksum_file_from_input(file_info: *mut gio::GFileInfo, xattrs: *mut glib::GVariant, in_: *mut gio::GInputStream, objtype: OstreeObjectType, out_csum: *mut *mut [u8; 32], cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_checksum_from_bytes(csum: *mut [u8; 32]) -> *mut c_char;
    pub fn ostree_checksum_from_bytes_v(csum_v: *mut glib::GVariant) -> *mut c_char;
    pub fn ostree_checksum_inplace_from_bytes(csum: *mut [u8; 32], buf: *mut c_char);
    pub fn ostree_checksum_inplace_to_bytes(checksum: *const c_char, buf: *mut u8);
    pub fn ostree_checksum_to_bytes(checksum: *const c_char) -> *mut [u8; 32];
    pub fn ostree_checksum_to_bytes_v(checksum: *const c_char) -> *mut glib::GVariant;
    pub fn ostree_cmd__private__() -> *const OstreeCmdPrivateVTable;
    pub fn ostree_cmp_checksum_bytes(a: *const u8, b: *const u8) -> c_int;
    pub fn ostree_commit_get_parent(commit_variant: *mut glib::GVariant) -> *mut c_char;
    pub fn ostree_commit_get_timestamp(commit_variant: *mut glib::GVariant) -> u64;
    pub fn ostree_content_file_parse(compressed: gboolean, content_path: *mut gio::GFile, trusted: gboolean, out_input: *mut *mut gio::GInputStream, out_file_info: *mut *mut gio::GFileInfo, out_xattrs: *mut *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_content_file_parse_at(compressed: gboolean, parent_dfd: c_int, path: *const c_char, trusted: gboolean, out_input: *mut *mut gio::GInputStream, out_file_info: *mut *mut gio::GFileInfo, out_xattrs: *mut *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_content_stream_parse(compressed: gboolean, input: *mut gio::GInputStream, input_length: u64, trusted: gboolean, out_input: *mut *mut gio::GInputStream, out_file_info: *mut *mut gio::GFileInfo, out_xattrs: *mut *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_create_directory_metadata(dir_info: *mut gio::GFileInfo, xattrs: *mut glib::GVariant) -> *mut glib::GVariant;
    pub fn ostree_diff_dirs(flags: OstreeDiffFlags, a: *mut gio::GFile, b: *mut gio::GFile, modified: *mut glib::GPtrArray, removed: *mut glib::GPtrArray, added: *mut glib::GPtrArray, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_diff_print(a: *mut gio::GFile, b: *mut gio::GFile, modified: *mut glib::GPtrArray, removed: *mut glib::GPtrArray, added: *mut glib::GPtrArray);
    pub fn ostree_hash_object_name(a: gconstpointer) -> c_uint;
    pub fn ostree_metadata_variant_type(objtype: OstreeObjectType) -> *const glib::GVariantType;
    pub fn ostree_object_from_string(str: *const c_char, out_checksum: *mut *mut c_char, out_objtype: *mut OstreeObjectType);
    pub fn ostree_object_name_deserialize(variant: *mut glib::GVariant, out_checksum: *mut *const c_char, out_objtype: *mut OstreeObjectType);
    pub fn ostree_object_name_serialize(checksum: *const c_char, objtype: OstreeObjectType) -> *mut glib::GVariant;
    pub fn ostree_object_to_string(checksum: *const c_char, objtype: OstreeObjectType) -> *mut c_char;
    pub fn ostree_object_type_from_string(str: *const c_char) -> OstreeObjectType;
    pub fn ostree_object_type_to_string(objtype: OstreeObjectType) -> *const c_char;
    pub fn ostree_parse_refspec(refspec: *const c_char, out_remote: *mut *mut c_char, out_ref: *mut *mut c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_raw_file_to_archive_z2_stream(input: *mut gio::GInputStream, file_info: *mut gio::GFileInfo, xattrs: *mut glib::GVariant, out_input: *mut *mut gio::GInputStream, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2017_3")]
    pub fn ostree_raw_file_to_archive_z2_stream_with_options(input: *mut gio::GInputStream, file_info: *mut gio::GFileInfo, xattrs: *mut glib::GVariant, options: *mut glib::GVariant, out_input: *mut *mut gio::GInputStream, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_raw_file_to_content_stream(input: *mut gio::GInputStream, file_info: *mut gio::GFileInfo, xattrs: *mut glib::GVariant, out_input: *mut *mut gio::GInputStream, out_length: *mut u64, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_validate_checksum_string(sha256: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_validate_rev(rev: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_validate_structureof_checksum_string(checksum: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_validate_structureof_commit(commit: *mut glib::GVariant, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_validate_structureof_csum_v(checksum: *mut glib::GVariant, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_validate_structureof_dirmeta(dirmeta: *mut glib::GVariant, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_validate_structureof_dirtree(dirtree: *mut glib::GVariant, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_validate_structureof_file_mode(mode: u32, error: *mut *mut glib::GError) -> gboolean;
    pub fn ostree_validate_structureof_objtype(objtype: c_uchar, error: *mut *mut glib::GError) -> gboolean;

}
