// This file was generated by gir (???) from gir-files (???)
// DO NOT EDIT

use ffi;
use glib::Value;
use glib::translate::*;
use gobject_ffi;
use std::mem;

glib_wrapper! {
    pub struct Repo(Object<ffi::OstreeRepo>);

    match fn {
        get_type => || ffi::ostree_repo_get_type(),
    }
}

impl Repo {
    //pub fn new<T: IsA</*Ignored*/gio::File>>(path: &T) -> Repo {
    //    unsafe { TODO: call ffi::ostree_repo_new() }
    //}

    pub fn new_default() -> Repo {
        unsafe {
            from_glib_full(ffi::ostree_repo_new_default())
        }
    }

    //pub fn new_for_sysroot_path<T: IsA</*Ignored*/gio::File>, U: IsA</*Ignored*/gio::File>>(repo_path: &T, sysroot_path: &U) -> Repo {
    //    unsafe { TODO: call ffi::ostree_repo_new_for_sysroot_path() }
    //}

    //pub fn abort_transaction(&self, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_abort_transaction() }
    //}

    //pub fn add_gpg_signature_summary<'a, T: Into<Option<&'a str>>>(&self, key_id: &[&str], homedir: T, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_add_gpg_signature_summary() }
    //}

    //pub fn append_gpg_signature(&self, commit_checksum: &str, signature_bytes: /*Ignored*/&glib::Bytes, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_append_gpg_signature() }
    //}

    //pub fn checkout_at(&self, options: /*Ignored*/Option<&mut RepoCheckoutAtOptions>, destination_dfd: i32, destination_path: &str, commit: &str, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_checkout_at() }
    //}

    //pub fn checkout_gc(&self, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_checkout_gc() }
    //}

    //pub fn checkout_tree<T: IsA</*Ignored*/gio::File>>(&self, mode: /*Ignored*/RepoCheckoutMode, overwrite_mode: /*Ignored*/RepoCheckoutOverwriteMode, destination: &T, source: &RepoFile, source_info: /*Ignored*/&gio::FileInfo, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_checkout_tree() }
    //}

    //pub fn checkout_tree_at(&self, options: /*Ignored*/Option<&mut RepoCheckoutOptions>, destination_dfd: i32, destination_path: &str, commit: &str, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_checkout_tree_at() }
    //}

    //pub fn commit_transaction(&self, out_stats: /*Ignored*/RepoTransactionStats, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_commit_transaction() }
    //}

    //pub fn copy_config(&self) -> /*Ignored*/Option<glib::KeyFile> {
    //    unsafe { TODO: call ffi::ostree_repo_copy_config() }
    //}

    //pub fn create(&self, mode: /*Ignored*/RepoMode, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_create() }
    //}

    //pub fn delete_object(&self, objtype: /*Ignored*/ObjectType, sha256: &str, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_delete_object() }
    //}

    //pub fn export_tree_to_archive(&self, opts: /*Ignored*/&mut RepoExportArchiveOptions, root: &RepoFile, archive: /*Unimplemented*/Option<Fundamental: Pointer>, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_export_tree_to_archive() }
    //}

    //pub fn get_config(&self) -> /*Ignored*/Option<glib::KeyFile> {
    //    unsafe { TODO: call ffi::ostree_repo_get_config() }
    //}

    pub fn get_dfd(&self) -> i32 {
        unsafe {
            ffi::ostree_repo_get_dfd(self.to_glib_none().0)
        }
    }

    pub fn get_disable_fsync(&self) -> bool {
        unsafe {
            from_glib(ffi::ostree_repo_get_disable_fsync(self.to_glib_none().0))
        }
    }

    //pub fn get_mode(&self) -> /*Ignored*/RepoMode {
    //    unsafe { TODO: call ffi::ostree_repo_get_mode() }
    //}

    pub fn get_parent(&self) -> Option<Repo> {
        unsafe {
            from_glib_none(ffi::ostree_repo_get_parent(self.to_glib_none().0))
        }
    }

    //pub fn get_path(&self) -> /*Ignored*/Option<gio::File> {
    //    unsafe { TODO: call ffi::ostree_repo_get_path() }
    //}

    //pub fn get_remote_boolean_option(&self, remote_name: &str, option_name: &str, default_value: bool, error: /*Ignored*/Option<Error>) -> Result<(bool), Error> {
    //    unsafe { TODO: call ffi::ostree_repo_get_remote_boolean_option() }
    //}

    //pub fn get_remote_list_option(&self, remote_name: &str, option_name: &str, out_value: /*Unimplemented*/Vec<String>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_get_remote_list_option() }
    //}

    //pub fn get_remote_option<'a, T: Into<Option<&'a str>>>(&self, remote_name: &str, option_name: &str, default_value: T, out_value: /*Unimplemented*/String, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_get_remote_option() }
    //}

    //pub fn gpg_verify_data<'a, T: Into<Option<&'a str>>, U: IsA</*Ignored*/gio::File>, V: IsA</*Ignored*/gio::File>>(&self, remote_name: T, data: /*Ignored*/&glib::Bytes, signatures: /*Ignored*/&glib::Bytes, keyringdir: Option<&U>, extra_keyring: Option<&V>, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> /*Ignored*/Option<GpgVerifyResult> {
    //    unsafe { TODO: call ffi::ostree_repo_gpg_verify_data() }
    //}

    //pub fn has_object(&self, objtype: /*Ignored*/ObjectType, checksum: &str, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> Result<(bool), Error> {
    //    unsafe { TODO: call ffi::ostree_repo_has_object() }
    //}

    //pub fn import_archive_to_mtree(&self, opts: /*Ignored*/&mut RepoImportArchiveOptions, archive: /*Unimplemented*/Option<Fundamental: Pointer>, mtree: /*Ignored*/&MutableTree, modifier: /*Ignored*/Option<&RepoCommitModifier>, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_import_archive_to_mtree() }
    //}

    //pub fn import_object_from(&self, source: &Repo, objtype: /*Ignored*/ObjectType, checksum: &str, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_import_object_from() }
    //}

    //pub fn import_object_from_with_trust(&self, source: &Repo, objtype: /*Ignored*/ObjectType, checksum: &str, trusted: bool, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_import_object_from_with_trust() }
    //}

    pub fn is_system(&self) -> bool {
        unsafe {
            from_glib(ffi::ostree_repo_is_system(self.to_glib_none().0))
        }
    }

    //pub fn is_writable(&self, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_is_writable() }
    //}

    //pub fn list_commit_objects_starting_with(&self, start: &str, out_commits: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 2, id: 176 }/TypeId { ns_id: 2, id: 176 }, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_list_commit_objects_starting_with() }
    //}

    //pub fn list_objects(&self, flags: /*Ignored*/RepoListObjectsFlags, out_objects: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 2, id: 176 }/TypeId { ns_id: 2, id: 176 }, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_list_objects() }
    //}

    //pub fn list_refs<'a, T: Into<Option<&'a str>>>(&self, refspec_prefix: T, out_all_refs: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_list_refs() }
    //}

    //pub fn list_refs_ext<'a, T: Into<Option<&'a str>>>(&self, refspec_prefix: T, out_all_refs: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, flags: /*Ignored*/RepoListRefsExtFlags, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_list_refs_ext() }
    //}

    //pub fn list_static_delta_names(&self, out_deltas: /*Unknown conversion*//*Unimplemented*/PtrArray TypeId { ns_id: 0, id: 28 }, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_list_static_delta_names() }
    //}

    //pub fn load_commit(&self, checksum: &str, out_commit: /*Ignored*/glib::Variant, error: /*Ignored*/Option<Error>) -> Result<(/*Ignored*/RepoCommitState), Error> {
    //    unsafe { TODO: call ffi::ostree_repo_load_commit() }
    //}

    //pub fn load_file(&self, checksum: &str, out_input: /*Ignored*/gio::InputStream, out_file_info: /*Ignored*/gio::FileInfo, out_xattrs: /*Ignored*/glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_load_file() }
    //}

    //pub fn load_object_stream(&self, objtype: /*Ignored*/ObjectType, checksum: &str, out_input: /*Ignored*/gio::InputStream, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> Result<(u64), Error> {
    //    unsafe { TODO: call ffi::ostree_repo_load_object_stream() }
    //}

    //pub fn load_variant(&self, objtype: /*Ignored*/ObjectType, sha256: &str, out_variant: /*Ignored*/glib::Variant, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_load_variant() }
    //}

    //pub fn load_variant_if_exists(&self, objtype: /*Ignored*/ObjectType, sha256: &str, out_variant: /*Ignored*/glib::Variant, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_load_variant_if_exists() }
    //}

    //pub fn open(&self, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_open() }
    //}

    //pub fn prepare_transaction(&self, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> Result<(bool), Error> {
    //    unsafe { TODO: call ffi::ostree_repo_prepare_transaction() }
    //}

    //pub fn prune(&self, flags: /*Ignored*/RepoPruneFlags, depth: i32, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> Result<(i32, i32, u64), Error> {
    //    unsafe { TODO: call ffi::ostree_repo_prune() }
    //}

    //pub fn prune_from_reachable(&self, options: /*Ignored*/&mut RepoPruneOptions, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> Result<(i32, i32, u64), Error> {
    //    unsafe { TODO: call ffi::ostree_repo_prune_from_reachable() }
    //}

    //pub fn prune_static_deltas<'a, T: Into<Option<&'a str>>>(&self, commit: T, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_prune_static_deltas() }
    //}

    //pub fn pull(&self, remote_name: &str, refs_to_fetch: &[&str], flags: /*Ignored*/RepoPullFlags, progress: /*Ignored*/Option<&AsyncProgress>, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_pull() }
    //}

    //pub fn pull_one_dir(&self, remote_name: &str, dir_to_pull: &str, refs_to_fetch: &[&str], flags: /*Ignored*/RepoPullFlags, progress: /*Ignored*/Option<&AsyncProgress>, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_pull_one_dir() }
    //}

    //pub fn pull_with_options(&self, remote_name_or_baseurl: &str, options: /*Ignored*/&glib::Variant, progress: /*Ignored*/Option<&AsyncProgress>, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_pull_with_options() }
    //}

    //pub fn query_object_storage_size(&self, objtype: /*Ignored*/ObjectType, sha256: &str, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> Result<(u64), Error> {
    //    unsafe { TODO: call ffi::ostree_repo_query_object_storage_size() }
    //}

    //pub fn read_commit(&self, ref_: &str, out_root: /*Ignored*/gio::File, out_commit: /*Unimplemented*/String, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_read_commit() }
    //}

    //pub fn read_commit_detached_metadata(&self, checksum: &str, out_metadata: /*Ignored*/glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_read_commit_detached_metadata() }
    //}

    //pub fn regenerate_summary(&self, additional_metadata: /*Ignored*/Option<&glib::Variant>, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_regenerate_summary() }
    //}

    //pub fn reload_config(&self, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_reload_config() }
    //}

    //pub fn remote_add(&self, name: &str, url: &str, options: /*Ignored*/Option<&glib::Variant>, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_remote_add() }
    //}

    //pub fn remote_change<T: IsA</*Ignored*/gio::File>>(&self, sysroot: Option<&T>, changeop: /*Ignored*/RepoRemoteChange, name: &str, url: &str, options: /*Ignored*/Option<&glib::Variant>, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_remote_change() }
    //}

    //pub fn remote_delete(&self, name: &str, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_remote_delete() }
    //}

    //pub fn remote_fetch_summary(&self, name: &str, out_summary: /*Ignored*/glib::Bytes, out_signatures: /*Ignored*/glib::Bytes, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_remote_fetch_summary() }
    //}

    //pub fn remote_fetch_summary_with_options(&self, name: &str, options: /*Ignored*/Option<&glib::Variant>, out_summary: /*Ignored*/glib::Bytes, out_signatures: /*Ignored*/glib::Bytes, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_remote_fetch_summary_with_options() }
    //}

    //pub fn remote_get_gpg_verify(&self, name: &str, error: /*Ignored*/Option<Error>) -> Result<(bool), Error> {
    //    unsafe { TODO: call ffi::ostree_repo_remote_get_gpg_verify() }
    //}

    //pub fn remote_get_gpg_verify_summary(&self, name: &str, error: /*Ignored*/Option<Error>) -> Result<(bool), Error> {
    //    unsafe { TODO: call ffi::ostree_repo_remote_get_gpg_verify_summary() }
    //}

    //pub fn remote_get_url(&self, name: &str, out_url: /*Unimplemented*/String, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_remote_get_url() }
    //}

    //pub fn remote_gpg_import<T: IsA</*Ignored*/gio::InputStream>>(&self, name: &str, source_stream: Option<&T>, key_ids: &[&str], out_imported: u32, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_remote_gpg_import() }
    //}

    pub fn remote_list(&self) -> (Vec<String>, u32) {
        unsafe {
            let mut out_n_remotes = mem::uninitialized();
            let ret = FromGlibPtrContainer::from_glib_full(ffi::ostree_repo_remote_list(self.to_glib_none().0, &mut out_n_remotes));
            (ret, out_n_remotes)
        }
    }

    //pub fn remote_list_refs(&self, remote_name: &str, out_all_refs: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_remote_list_refs() }
    //}

    //pub fn resolve_rev(&self, refspec: &str, allow_noent: bool, out_rev: /*Unimplemented*/String, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_resolve_rev() }
    //}

    //pub fn resolve_rev_ext(&self, refspec: &str, allow_noent: bool, flags: /*Ignored*/RepoResolveRevExtFlags, out_rev: /*Unimplemented*/String, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_resolve_rev_ext() }
    //}

    //pub fn scan_hardlinks(&self, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_scan_hardlinks() }
    //}

    //pub fn set_cache_dir(&self, dfd: i32, path: &str, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_set_cache_dir() }
    //}

    pub fn set_disable_fsync(&self, disable_fsync: bool) {
        unsafe {
            ffi::ostree_repo_set_disable_fsync(self.to_glib_none().0, disable_fsync.to_glib());
        }
    }

    //pub fn set_ref_immediate<'a, 'b, T: Into<Option<&'a str>>, U: Into<Option<&'b str>>>(&self, remote: T, ref_: &str, checksum: U, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_set_ref_immediate() }
    //}

    //pub fn sign_commit<'a, T: Into<Option<&'a str>>>(&self, commit_checksum: &str, key_id: &str, homedir: T, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_sign_commit() }
    //}

    //pub fn sign_delta(&self, from_commit: &str, to_commit: &str, key_id: &str, homedir: &str, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_sign_delta() }
    //}

    //pub fn static_delta_execute_offline<T: IsA</*Ignored*/gio::File>>(&self, dir_or_file: &T, skip_validation: bool, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_static_delta_execute_offline() }
    //}

    //pub fn static_delta_generate(&self, opt: /*Ignored*/StaticDeltaGenerateOpt, from: &str, to: &str, metadata: /*Ignored*/Option<&glib::Variant>, params: /*Ignored*/Option<&glib::Variant>, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_static_delta_generate() }
    //}

    pub fn transaction_set_ref<'a, T: Into<Option<&'a str>>>(&self, remote: T, ref_: &str, checksum: &str) {
        unsafe {
            ffi::ostree_repo_transaction_set_ref(self.to_glib_none().0, remote.into().to_glib_none().0, ref_.to_glib_none().0, checksum.to_glib_none().0);
        }
    }

    pub fn transaction_set_refspec(&self, refspec: &str, checksum: &str) {
        unsafe {
            ffi::ostree_repo_transaction_set_refspec(self.to_glib_none().0, refspec.to_glib_none().0, checksum.to_glib_none().0);
        }
    }

    //pub fn traverse_commit(&self, commit_checksum: &str, maxdepth: i32, out_reachable: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 2, id: 176 }/TypeId { ns_id: 2, id: 176 }, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_traverse_commit() }
    //}

    //pub fn traverse_commit_union(&self, commit_checksum: &str, maxdepth: i32, inout_reachable: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 25 }/TypeId { ns_id: 0, id: 25 }, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_traverse_commit_union() }
    //}

    //pub fn verify_commit<T: IsA</*Ignored*/gio::File>, U: IsA</*Ignored*/gio::File>>(&self, commit_checksum: &str, keyringdir: Option<&T>, extra_keyring: Option<&U>, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_verify_commit() }
    //}

    //pub fn verify_commit_ext<T: IsA</*Ignored*/gio::File>, U: IsA</*Ignored*/gio::File>>(&self, commit_checksum: &str, keyringdir: Option<&T>, extra_keyring: Option<&U>, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> /*Ignored*/Option<GpgVerifyResult> {
    //    unsafe { TODO: call ffi::ostree_repo_verify_commit_ext() }
    //}

    //pub fn verify_commit_for_remote(&self, commit_checksum: &str, remote_name: &str, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> /*Ignored*/Option<GpgVerifyResult> {
    //    unsafe { TODO: call ffi::ostree_repo_verify_commit_for_remote() }
    //}

    //pub fn verify_summary(&self, remote_name: &str, summary: /*Ignored*/&glib::Bytes, signatures: /*Ignored*/&glib::Bytes, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> /*Ignored*/Option<GpgVerifyResult> {
    //    unsafe { TODO: call ffi::ostree_repo_verify_summary() }
    //}

    //pub fn write_archive_to_mtree<T: IsA</*Ignored*/gio::File>>(&self, archive: &T, mtree: /*Ignored*/&MutableTree, modifier: /*Ignored*/Option<&RepoCommitModifier>, autocreate_parents: bool, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_write_archive_to_mtree() }
    //}

    //pub fn write_commit<'a, 'b, 'c, T: Into<Option<&'a str>>, U: Into<Option<&'b str>>, V: Into<Option<&'c str>>>(&self, parent: T, subject: U, body: V, metadata: /*Ignored*/Option<&glib::Variant>, root: &RepoFile, out_commit: /*Unimplemented*/String, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_write_commit() }
    //}

    //pub fn write_commit_detached_metadata(&self, checksum: &str, metadata: /*Ignored*/Option<&glib::Variant>, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_write_commit_detached_metadata() }
    //}

    //pub fn write_commit_with_time<'a, 'b, 'c, T: Into<Option<&'a str>>, U: Into<Option<&'b str>>, V: Into<Option<&'c str>>>(&self, parent: T, subject: U, body: V, metadata: /*Ignored*/Option<&glib::Variant>, root: &RepoFile, time: u64, out_commit: /*Unimplemented*/String, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_write_commit_with_time() }
    //}

    //pub fn write_config(&self, new_config: /*Ignored*/&glib::KeyFile, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_write_config() }
    //}

    //pub fn write_content<'a, T: Into<Option<&'a str>>, U: IsA</*Ignored*/gio::InputStream>>(&self, expected_checksum: T, object_input: &U, length: u64, out_csum: /*Unknown conversion*//*Unimplemented*/FixedArray TypeId { ns_id: 0, id: 3 }; 32, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_write_content() }
    //}

    //pub fn write_content_async<'a, T: Into<Option<&'a str>>, U: IsA</*Ignored*/gio::InputStream>>(&self, expected_checksum: T, object: &U, length: u64, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: /*Unknown conversion*//*Unimplemented*/AsyncReadyCallback, user_data: /*Unimplemented*/Option<Fundamental: Pointer>) {
    //    unsafe { TODO: call ffi::ostree_repo_write_content_async() }
    //}

    //pub fn write_content_finish<T: IsA</*Ignored*/gio::AsyncResult>>(&self, result: &T, error: /*Ignored*/Option<Error>) -> Result<(u8), Error> {
    //    unsafe { TODO: call ffi::ostree_repo_write_content_finish() }
    //}

    //pub fn write_content_trusted<T: IsA</*Ignored*/gio::InputStream>>(&self, checksum: &str, object_input: &T, length: u64, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_write_content_trusted() }
    //}

    //pub fn write_dfd_to_mtree(&self, dfd: i32, path: &str, mtree: /*Ignored*/&MutableTree, modifier: /*Ignored*/Option<&RepoCommitModifier>, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_write_dfd_to_mtree() }
    //}

    //pub fn write_directory_to_mtree<T: IsA</*Ignored*/gio::File>>(&self, dir: &T, mtree: /*Ignored*/&MutableTree, modifier: /*Ignored*/Option<&RepoCommitModifier>, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_write_directory_to_mtree() }
    //}

    //pub fn write_metadata<'a, T: Into<Option<&'a str>>>(&self, objtype: /*Ignored*/ObjectType, expected_checksum: T, object: /*Ignored*/&glib::Variant, out_csum: /*Unknown conversion*//*Unimplemented*/FixedArray TypeId { ns_id: 0, id: 3 }; 32, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_write_metadata() }
    //}

    //pub fn write_metadata_async<'a, T: Into<Option<&'a str>>>(&self, objtype: /*Ignored*/ObjectType, expected_checksum: T, object: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: /*Unknown conversion*//*Unimplemented*/AsyncReadyCallback, user_data: /*Unimplemented*/Option<Fundamental: Pointer>) {
    //    unsafe { TODO: call ffi::ostree_repo_write_metadata_async() }
    //}

    //pub fn write_metadata_finish<T: IsA</*Ignored*/gio::AsyncResult>>(&self, result: &T, out_csum: u8, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_write_metadata_finish() }
    //}

    //pub fn write_metadata_stream_trusted<T: IsA</*Ignored*/gio::InputStream>>(&self, objtype: /*Ignored*/ObjectType, checksum: &str, object_input: &T, length: u64, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_write_metadata_stream_trusted() }
    //}

    //pub fn write_metadata_trusted(&self, objtype: /*Ignored*/ObjectType, checksum: &str, variant: /*Ignored*/&glib::Variant, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_write_metadata_trusted() }
    //}

    //pub fn write_mtree(&self, mtree: /*Ignored*/&MutableTree, out_file: /*Ignored*/gio::File, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_write_mtree() }
    //}

    //pub fn set_property_path(&self, path: /*Ignored*/Option<&gio::File>) {
    //    unsafe {
    //        gobject_ffi::g_object_set_property(self.to_glib_none().0, "path".to_glib_none().0, Value::from(path).to_glib_none().0);
    //    }
    //}

    pub fn get_property_remotes_config_dir(&self) -> Option<String> {
        let mut value = Value::from(None::<&str>);
        unsafe {
            gobject_ffi::g_object_get_property(self.to_glib_none().0, "remotes-config-dir".to_glib_none().0, value.to_glib_none_mut().0);
        }
        value.get()
    }

    pub fn set_property_remotes_config_dir(&self, remotes_config_dir: Option<&str>) {
        unsafe {
            gobject_ffi::g_object_set_property(self.to_glib_none().0, "remotes-config-dir".to_glib_none().0, Value::from(remotes_config_dir).to_glib_none().0);
        }
    }

    //pub fn get_property_sysroot_path(&self) -> /*Ignored*/Option<gio::File> {
    //    let mut value = Value::from(None::<&/*Ignored*/gio::File>);
    //    unsafe {
    //        gobject_ffi::g_object_get_property(self.to_glib_none().0, "sysroot-path".to_glib_none().0, value.to_glib_none_mut().0);
    //    }
    //    value.get()
    //}

    //pub fn set_property_sysroot_path(&self, sysroot_path: /*Ignored*/Option<&gio::File>) {
    //    unsafe {
    //        gobject_ffi::g_object_set_property(self.to_glib_none().0, "sysroot-path".to_glib_none().0, Value::from(sysroot_path).to_glib_none().0);
    //    }
    //}

    //pub fn mode_from_string(mode: &str, out_mode: /*Ignored*/RepoMode, error: /*Ignored*/Option<Error>) -> bool {
    //    unsafe { TODO: call ffi::ostree_repo_mode_from_string() }
    //}

    //pub fn pull_default_console_progress_changed(progress: /*Ignored*/&AsyncProgress, user_data: /*Unimplemented*/Option<Fundamental: Pointer>) {
    //    unsafe { TODO: call ffi::ostree_repo_pull_default_console_progress_changed() }
    //}

    //pub fn traverse_new_reachable() -> /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 2, id: 176 }/TypeId { ns_id: 2, id: 176 } {
    //    unsafe { TODO: call ffi::ostree_repo_traverse_new_reachable() }
    //}

    //pub fn connect_gpg_verify_result<Unsupported or ignored types>(&self, f: F) -> u64 {
    //    Ignored result: OSTree.GpgVerifyResult
    //}
}
